
import pandas as pd
import numpy as np
import random
import os
import math
import psycopg2
from dotenv import load_dotenv
load_dotenv()

def get_products():
    conn = psycopg2.connect(
            host=os.getenv('DB_HOST'),
            port=os.getenv('DB_PORT'),
            database=os.getenv('DB_NAME'),
            user=os.getenv('DB_USERNAME'),
            password=os.getenv('DB_PASSWORD'))
    sql_query = pd.read_sql_query ('''
                               SELECT
                               *
                               FROM products
                               ''', conn)
    data = pd.DataFrame(sql_query, columns = ['id', 'product_name', 'weight', 'buy_price', 'sale_price'])
    return data

def get_parameters():
    conn = psycopg2.connect(
            host=os.getenv('DB_HOST'),
            port=os.getenv('DB_PORT'),
            database=os.getenv('DB_NAME'),
            user=os.getenv('DB_USERNAME'),
            password=os.getenv('DB_PASSWORD'))
    cur = conn.cursor()
    cur.execute("SELECT * FROM variables")
    var_ai = cur.fetchone()
    cur.close()
    conn.close()
    data = {
            "id": int(var_ai[0]),
            "n_pop": int(var_ai[1]),
            "n_generations": int(var_ai[2]), 
            "p_selection": float(var_ai[3]),
            "p_mutate" : float(var_ai[4]),
            "max_value": int(var_ai[5]),
            "min_value": int(var_ai[6]),
            "max_weight": float(var_ai[7]),
            "budget": int(var_ai[8])                    
            }
    return data

products = get_products()
parameters = get_parameters()
n_product = len(products.index)

def init_population(n):
    """Return a population of n random solutions. Each solution is 
    a nx7 list, with each row representing the quantity of the products to buy.
    """
    new_population = np.random.randint(low=parameters['min_value'], high=parameters['max_value'], size=(n, len(products.index)))
    # print(new_population)
    return new_population



def init_population(n):
    """Return a population of n random solutions. Each solution is 
    a 4x3 list, with each element being a selection of 3 distinct
    random barrels.
    """
    global n_product
    new_population = np.random.randint(low=parameters['min_value'], high=parameters['max_value'], size=(n, n_product))
    return new_population

def fitness(candidate):
    """Give the score of the 
    """
    result_weight = (products['weight'] * candidate).sum()
    result_buy = (products['buy_price'] * candidate).sum()
    result_sale = (products['sale_price'] * candidate).sum()

    if result_weight > parameters['max_weight']:
        return (15 - result_weight) * (parameters['budget']/parameters['max_weight'])
    if result_buy > parameters['budget']:
        return 1000 - result_buy
    return result_sale - result_buy

def evaluation(population):
    """Return a population sorted by fitness."""
    return sorted(population, key= lambda x:fitness(x), reverse= True)

def selection(population, percentage_selection):
    """Return top half of population."""
    n_parents = math.ceil(len(population) * percentage_selection / 2) * 2
    n_parents = int(n_parents)
    return population[:n_parents]

def crossover(parents : np.array):
    """Return a new population, generated by pairing best solution with second best, and so forth. 
    """
    children = np.empty((len(parents), n_product), dtype=int)
    n_children = len(parents)
    for i in range(n_children): # Cross N times
        if i % 2 == 0:
            parent1, parent2 = parents[i], parents[i+1]
            child1 = np.empty(n_product)
            child2 = np.empty(n_product)
            child1[:int(n_product / 2)] = parent1[:int(n_product / 2)]
            child1[int(n_product / 2):] = parent2[int((n_product / 2)):]
            child2[:int(n_product / 2)] = parent2[:int(n_product / 2)]
            child2[int(n_product / 2):] = parent1[int(n_product / 2):]
            children[i] = child1
            children[i+1] = child2
    return children

def mutation(population):
    """Return a mutated population (out-of-place). For each
    candidate, mutate with probability p_mutate.
    If mutate:
        Select random slot.
        Select a randon integer to change the value excluding the preceding value.
    Else:
        The candidate is not affected.
    Return new (partially mutated) population.
    """
    mutated_population = population.copy()
    for index in range(population.shape[0]):
        if random.random() < parameters['p_mutate']:
            # Mutate
            # Choose random slot
            o = random.randrange(n_product)
            mutated_population[index][o] = random.choice([x for x in range(parameters['min_value'], parameters['max_value']+1) if x != mutated_population[index][o]])
    return mutated_population



def solution(): 
    pop = init_population(parameters['n_pop'])
    ranking = evaluation(pop)
    for i in range(parameters['n_generations']):
        parents = selection(ranking, parameters['p_selection'])
        children = crossover(parents)
        children = mutation(children)
        new_pop = np.empty((parameters['n_pop'], n_product), dtype=int)
        new_pop[:children.shape[0]] = children
        new_pop[children.shape[0]:] = pop[:(parameters['n_pop']-children.shape[0])]
        pop = evaluation(new_pop)
    revenue = int(fitness(pop[0]))
    data = products[['id', 'product_name']]
    data["quantity"] = pop[0].tolist()
    data = data.to_dict("records")
    return data, revenue

if __name__ == "__main__":
   combination, revenue = solution()
   print(combination, revenue)
